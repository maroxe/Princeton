#+HTML_HEAD:    <link rel="stylesheet" type="text/css" href="../../css/org-style.css" />
#+HTML_HEAD:    <link rel="stylesheet" type="text/css" href="../../css/special-block.css" />
* Discover Gravitational Wves in Your Room

#+name: helper_function 
#+begin_src R :exports none :session :tangle yes
library(ggplot2)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

#+end_src

#+RESULTS: helper_function


#+name: seed
#+begin_src R :session :exports none :results none
    set.seed(10)
#+end_src



** 1.1

   Loading the Data
   
   #+name: load_data
   #+begin_src R :session :cache yes
  ts <- read.table('LIGO.Hanford.Data.txt')
  ts.theory <- read.table('LIGO.Hanford.Theory.txt')
  names(ts) <- c("t", "y")
  names(ts.theory) <- c("t", "y")
  N <- length(ts$y)
   #+end_src
      
   #+RESULTS[89c5c8bb3ef6370c1efff00efd0251fcecc3b3bb]: load_data
   : 3441


   
   #+name: matrix_C
   #+begin_src R :session :cache yes
  C <- matrix(sqrt(1 / N), N, N)
  for(j in 2:N) 
      for(k in 1:N)
          C[j, k] = sqrt(2 / T) * cos(pi * (2*k-1) * (j - 1) / (2*N) )
   #+end_src

   #+RESULTS[19ed51fbd27982def9ea7ff162bebb1f8ba50aec]: matrix_C



   #+name: lasso
   #+begin_src R :session :cache yes
  library(glmnet)
  lasso.model <- cv.glmnet(C, ts$y, alpha=1, nfolds=10, intercept=F)
  w.hat <- coef(lasso.model, s='lambda.1se')[-1]
  w.inverse <- solve(C, ts$y)
  print(lasso.model$lambda.1se )
   #+end_src

   #+RESULTS[9278f3c2909ce5d94f5e6cbd40ba6a68848fb9bf]: lasso
   : 0.0035151690881434





#+name: plotting
#+begin_src R :session :file comparesignals.png :results graphics
p1 <- ggplot(data=NULL, aes(x=ts$t, y=w.hat)) + geom_point()
p2 <- ggplot(data=NULL, aes(x=ts$t, y=w.inverse)) + geom_point()
p3 <- ggplot(data=NULL, aes(x=w.hat, y=w.inverse)) + geom_point()
multiplot(p1, p2, p3)
#+end_src

#+RESULTS: plotting
[[file:comparesignals.png]]




[[file:comparesignals.png]]


** 1.2


We write $\beta$ as $(\underbrace{\beta_1}_n, \underbrace{\beta_2}_n)$ , then $\Psi \beta = \beta_1 +  C \beta_2$
The Lasso try to find a sparse solution in the time and frequency domain at the same time.


#+begin_src R :session :cache yes
  phi <- cbind(diag(N), C)
  lasso.model.2 <- cv.glmnet(phi, ts$y, alpha=1, nfolds=10, intercept=F)
  beta.hat <- coef(lasso.model.2, s='lambda.1se')[-1]
  print(paste("lambda 1se:", lasso.model$lambda.1se))
#+end_src

#+RESULTS[a129d1ad76e9080629900645618f4261ef7b6e42]:
: lambda 1se: 0.0035151690881434






#+begin_src R :session :file denoise.png :results graphics
  ts$y.denoised <- beta.hat[1:N] + C%*%beta.hat[N + 1:N]
  ts$y.lasso <- C %*% w.hat
  p1 <- ggplot(data=ts, aes(x=t, y=y.denoised)) + geom_point()
  p2 <- ggplot(data=ts, aes(x=t, y=y.lasso)) + geom_point()
  p3 <- ggplot(data=ts.theory, aes(x=t, y=y)) + geom_point()
  multiplot(p1, p2, p3, cols=1)
#+end_src

#+RESULTS:
[[file:denoise.png]]



[[file:denoise.png]]


* Q2
  
** 2.1
   
#+include: "q2.tex" 

















